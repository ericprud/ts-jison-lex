// return next match in input
function next () {
  if (this.done) {
    return this.EOF;
  }
  if (!this._input) {
    this.done = true;
  }

  var token,
      match,
      tempMatch,
      index;
  if (!this._more) {
    this.yytext = '';
    this.match = '';
  }
  var rules = this._currentRules();
  for (var i = 0; i < rules.length; i++) {
    tempMatch = this._input.match(this.rules[rules[i]]);
    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
      match = tempMatch;
      index = i;
      if (this.options.backtrack_lexer) {
        token = this.test_match(tempMatch, rules[i]);
        if (token !== false) {
          return token;
        } else if (this._backtrack) {
          match = false;
          continue; // rule action called reject() implying a rule MISmatch.
        } else {
          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
          return false;
        }
      } else if (!this.options.flex) {
        break;
      }
    }
  }
  if (match) {
    token = this.test_match(match, rules[index]);
    if (token !== false) {
      return token;
    }
    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
    return false;
  }
  if (this._input === "") {
    return this.EOF;
  } else {
    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
      text: "",
      token: null,
      line: this.yylineno
    });
  }
}
